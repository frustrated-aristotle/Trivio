@page "{code}"
@model Trivio.Pages.GamePageModel
@{
}
<link rel="stylesheet" href="~/css/gamepage.css" asp-append-version="true" />


@section Scripts{
	<script>
		let code = "@Model.Code";
		const connection = new signalR.HubConnectionBuilder()
		.withUrl("/gameHub")
		.withAutomaticReconnect([0, 2000, 10000, 30000]) // Reconnect attempts with delays
		.configureLogging(signalR.LogLevel.Information)
		.build();
		
		let role = (sessionStorage.getItem('trivio_role') || "@Model.Role").toLowerCase();
		let username = sessionStorage.getItem('trivio_username') || "@Model.Username";
		let currentUsername = username; // Alias for consistency
		let isAdmin = @Model.IsAdmin.ToString().ToLower(); // Set initial admin status
		let roomPassword = "@(Model.Password ?? "")"; // Password for private rooms
		// Game timer variables
		let gameTimerInterval = null;
		let gameStartTime = null;
		
		// Initialize UI based on role
		initializeRoleBasedUI();

		// Initialize admin controls if user is already admin
		if (isAdmin) {
			// Wait for DOM to be ready, then show admin controls
			setTimeout(() => {
				showAdminControls();
			}, 100);
		}

		// Cleanup timer when page is unloaded
		window.addEventListener('beforeunload', function() {
			stopGameTimer();
		});

		// Connection state management
		connection.onreconnecting((error) => {
			console.log('SignalR reconnecting...', error);
			showConnectionStatus('Reconnecting...', 'warning');
		});

		connection.onreconnected((connectionId) => {
			console.log('SignalR reconnected with connection ID:', connectionId);
			showConnectionStatus('Connected', 'success');
			// Rejoin the room after reconnection (pass password if exists)
			connection.invoke('JoinRoom', parseInt(code), role, username, roomPassword || null)
				.catch(err => console.error('Failed to rejoin room:', err));
		});

		connection.onclose((error) => {
			console.log('SignalR connection closed:', error);
			showConnectionStatus('Disconnected', 'danger');
		});

		connection.start()
		.then(function(){
			console.log('SignalR connected');
			showConnectionStatus('Connected', 'success');
			// Pass password if provided (for private rooms)
			console.log("password is: " + roomPassword);
			return connection.invoke('JoinRoom', parseInt(code), role, username, roomPassword || null);
		})
		.catch(function (err) {
			console.error('SignalR connection failed:', err);
			console.log("Room password is " +roomPassword);
			showConnectionStatus('Connection Failed', 'danger');
		});

		// Initialize UI based on user role
		function initializeRoleBasedUI() {
			const playerInputArea = document.getElementById('playerInputArea');
			const spectatorGridArea = document.getElementById('spectatorGridArea');
			const guessInput = document.getElementById('guessInput');
			
			if (role === 'spectator') {
				console.log("Setting up spectator UI");
				// Show spectator grid, hide player input
				if (spectatorGridArea) {
					spectatorGridArea.style.display = 'grid';
					console.log("Showed spectator grid");
				}
				if (playerInputArea) {
					playerInputArea.style.display = 'none';
				}
			} else {
				// Show player input, hide spectator grid
				if (playerInputArea) {
					playerInputArea.style.display = 'block';
				}
				if (spectatorGridArea) {
					spectatorGridArea.style.display = 'none';
				}
				
				// Focus input for players and add typing event listener
				if (guessInput) {
					guessInput.focus();
					
					// Add typing event listener for players
					guessInput.addEventListener('input', function() {
						shareTypingInput(guessInput);
					});
				}
			}
		}

		function shareTypingInput(guessInput){
			connection.invoke('ShareTypingInput', {username: username, input: guessInput.value, code: code});
		}

		// Find the card that belongs to the current user
		function findCurrentUserCard() {
			for (let i = 1; i <= 4; i++) {
				const usernameElement = document.getElementById(`username${i}`);
				if (usernameElement && usernameElement.textContent.includes('(you)')) {
					return document.getElementById(`playerCard${i}`);
				}
			}
			return null;
		}

		// Get the input element for the current user
		function getCurrentUserInput() {
			if (role === 'spectator') {
				// For spectators, return null since they can't type
				return null;
			} else {
				// For players, return the main guess input
				return document.getElementById('guessInput');
			}
		}

		// Populate player cards with user data (only for spectators)
		function populatePlayerCards(users) {
			console.log("populatePlayerCards called with users:", users);
			console.log("Current role:", role);
			
			// Validate users array
			if (!users || !Array.isArray(users)) {
				console.error("Invalid users array:", users);
				return;
			}
			
			// Hide all cards first and clear content
			for (let i = 1; i <= 4; i++) {
				const card = document.getElementById(`playerCard${i}`);
				const usernameEl = document.getElementById(`username${i}`);
				const roleEl = document.getElementById(`role${i}`);
				const input = document.getElementById(`input${i}`);
				
				if (card && usernameEl && roleEl && input) {
					card.style.display = 'none';
					card.classList.remove('current-user', 'spectator', 'player', 'admin', 'typing');
					// Clear the content
					usernameEl.textContent = '';
					usernameEl.removeAttribute('data-username');
					roleEl.textContent = '';
					input.value = '';
					console.log(`Cleared card ${i}`);
				}
			}

			// Filter out users with invalid usernames
			const validUsers = users.filter(user => user && user.username && user.username.trim() !== '');
			const maxUsers = Math.min(validUsers.length, 4);
			console.log(`Populating ${maxUsers} valid users out of ${users.length} total`);
			
			for (let index = 0; index < maxUsers; index++) {
				const user = validUsers[index];
				const cardIndex = index + 1;
				const card = document.getElementById(`playerCard${cardIndex}`);
				const usernameEl = document.getElementById(`username${cardIndex}`);
				const roleEl = document.getElementById(`role${cardIndex}`);
				const input = document.getElementById(`input${cardIndex}`);
				
				console.log(`Setting up card ${cardIndex} for user:`, user.username, "role:", user.role);
				
				if (card && usernameEl && roleEl && input && user.username) {
					// Show the card
					card.style.display = 'flex';
					
					// IMPORTANT: Set username with data attribute for reliable lookup
					const displayUsername = user.username === currentUsername ? 
						`${user.username} (you)` : user.username;
					
					usernameEl.textContent = displayUsername;
					usernameEl.setAttribute('data-username', user.username); // Store raw username
					
					console.log(`Card ${cardIndex} - Set username to: "${usernameEl.textContent}"`);
					console.log(`Card ${cardIndex} - Data attribute: "${usernameEl.getAttribute('data-username')}"`);
					
					// Set role
					roleEl.textContent = user.role || 'player';
					roleEl.className = `player-role ${user.role || 'player'}`;
					
					// All inputs are disabled for spectators (they can only watch)
					input.disabled = true;
					input.value = ''; // Clear any previous input
					input.placeholder = user.role === 'spectator' ? "Spectating" : "Player typing...";
					
					// Add styling based on role
					if (user.role === 'spectator') {
						card.classList.add('spectator');
					} else {
						card.classList.add('player');
					}
					
					// Add current user styling
					if (user.username === currentUsername) {
						card.classList.add('current-user');
					}
					
					// Add admin styling
					if (user.role === 'admin') {
						card.classList.add('admin');
					}
					
					console.log(`Completed setup for card ${cardIndex}`);
				} else {
					console.log(`Missing elements for card ${cardIndex} or invalid user data:`, user);
				}
			}
			
			// Verify after population
			console.log("=== Verification after population ===");
			for (let i = 1; i <= 4; i++) {
				const usernameEl = document.getElementById(`username${i}`);
				if (usernameEl) {
					console.log(`Card ${i} final username: "${usernameEl.textContent}" (data: "${usernameEl.getAttribute('data-username')}")`);
				}
			}
		}

		// Connection status display function
		function showConnectionStatus(message, type) {
			// Remove existing status
			const existingStatus = document.getElementById('connectionStatus');
			if (existingStatus) {
				existingStatus.remove();
			}
			
			// Create new status indicator
			const statusDiv = document.createElement('div');
			statusDiv.id = 'connectionStatus';
			statusDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
			statusDiv.style.cssText = 'top: 10px; right: 10px; z-index: 9999; min-width: 200px;';
			statusDiv.innerHTML = `
				<i class="bi bi-${type === 'success' ? 'wifi' : type === 'warning' ? 'wifi-off' : 'x-circle'}"></i>
				${message}
				<button type="button" class="btn-close" data-bs-dismiss="alert"></button>
			`;
			
			document.body.appendChild(statusDiv);
			
			// Auto-hide success messages
			if (type === 'success') {
				setTimeout(() => {
					if (statusDiv && statusDiv.parentNode) {
						statusDiv.remove();
					}
				}, 3000);
			}
		}


		connection.on("UserJoined", function (username, role) {
			console.log(`User joined: ${username} as ${role}`);
			
			const listId = role === "player" || role === "admin" ? "playerList" : "spectatorList";
			const listElement = document.getElementById(listId);
			const listItem = document.createElement("div");
			listItem.className = "user-item";
			listItem.setAttribute('data-username', username);
			
			const roleColor = role === 'admin' ? 'warning' : (role === 'player' ? 'success' : 'secondary');
			const iconColor = role === 'admin' ? 'warning' : (role === 'player' ? 'success' : 'secondary');
			
			listItem.innerHTML = `
				<div class="user-info">
					<i class="bi bi-person-circle text-${iconColor}"></i>
					<span>${username}</span>
					${role === 'admin' ? '<i class="bi bi-crown-fill admin-crown text-warning ms-2" title="Room Owner"></i>' : ''}
				</div>
				<div class="user-actions">
					${role === 'player' || role === 'admin' ? '<span class="points-pill">0 pts</span>' : ''}
					<span class="badge badge-${roleColor}">${role}</span>
					${isAdmin && username !== currentUsername ? `
						<button class="btn btn-sm btn-outline-danger" onclick="kickUser('${username}')">
							<i class="bi bi-x-lg"></i>
						</button>
					` : ''}
				</div>
			`;
			
			// Add admin styling if this is the current user and they're admin
			if (username === currentUsername && role === 'admin') {
				listItem.classList.add('admin-owner');
			}
			listElement.appendChild(listItem);
			
			// If we're a spectator, refresh the player cards to include the new user
			if (role === 'spectator' && currentUsername !== username) {
				console.log("New user joined, refreshing player cards for spectator");
				// Get current users from the sidebar and refresh cards
				setTimeout(() => {
					forcePopulateCards();
				}, 100);
			}
			
			console.log(`${role} joined: ${username}`);
		});

		connection.on("UserListUpdated", function (users) {
			console.log("User list updated with points:", users);
			
			// Clear existing user lists
			const playerList = document.getElementById('playerList');
			const spectatorList = document.getElementById('spectatorList');
			
			if (playerList) playerList.innerHTML = '';
			if (spectatorList) spectatorList.innerHTML = '';
			
			// Check if current user is now admin
			const currentUser = users.find(user => user.username === currentUsername);
			if (currentUser && currentUser.role === 'admin') {
				isAdmin = true;
				showAdminControls();
			}
			
			// Update the 4-player grid FIRST before rebuilding sidebar
			// This is crucial for spectators to see the player cards
			if (role === 'spectator') {
				console.log("Spectator role detected, populating player cards");
				populatePlayerCards(users);
			}
			
			// Add users back with updated points and roles (for sidebar)
			users.forEach(user => {
				const listId = user.role === "player" || user.role === "admin" ? "playerList" : "spectatorList";
				const listElement = document.getElementById(listId);
				if (listElement) {
					const listItem = document.createElement("div");
					listItem.className = "user-item";
					listItem.setAttribute('data-username', user.username);
					
					const roleColor = user.role === 'admin' ? 'warning' : (user.role === 'player' ? 'success' : 'secondary');
					const iconColor = user.role === 'admin' ? 'warning' : (user.role === 'player' ? 'success' : 'secondary');
					
					listItem.innerHTML = `
						<div class="user-info">
							<i class="bi bi-person-circle text-${iconColor}"></i>
							<span>${user.username}</span>
							${user.role === 'admin' ? '<i class="bi bi-crown-fill admin-crown text-warning ms-2" title="Room Owner"></i>' : ''}
						</div>
						<div class="user-actions">
							${user.role === 'player' || user.role === 'admin' ? `<span class="points-pill">${user.points || 0} pts</span>` : ''}
							<span class="badge badge-${roleColor}">${user.role}</span>
							${isAdmin && user.username !== currentUsername ? `
								<button class="btn btn-sm btn-outline-danger" onclick="kickUser('${user.username}')">
									<i class="bi bi-x-lg"></i>
								</button>
							` : ''}
						</div>
					`;
					
					// Add admin styling if this is the current user and they're admin
					if (user.username === currentUsername && user.role === 'admin') {
						listItem.classList.add('admin-owner');
					}
					listElement.appendChild(listItem);
				}
			});
		});

		connection.on("UserLeft", function (connectionId) {
			// Remove user from both lists
			const playerList = document.getElementById('playerList');
			const spectatorList = document.getElementById('spectatorList');
			
			[playerList, spectatorList].forEach(list => {
				if (list) {
					const items = list.querySelectorAll('.user-item');
					items.forEach(item => {
						// Remove items that might be from the disconnected user
						// Note: We don't have direct connectionId mapping on client, 
						// so we'll rely on server-side cleanup
					});
				}
			});
			
			console.log(`User left: ${connectionId}`);
		});

		// Handle room ownership transfer
		connection.on("OwnerChanged", function (payload) {
			console.log("Room ownership changed:", payload);
			showConnectionStatus(payload.message, 'info');
			setTimeout(() => {
				showConnectionStatus('', 'success'); // Clear the message
			}, 3000);
		});

		connection.on("YouAreNowOwner", function(payload)
		{
			console.log("=== YouAreNowOwner event received ===");
			console.log("Payload:", payload);
			console.log("Current username:", currentUsername);
			console.log("isAdmin before:", isAdmin);
			
			// Update the global isAdmin variable
			isAdmin = true;
			console.log("isAdmin after:", isAdmin);
			
			// Show admin controls
			console.log("Calling showAdminControls...");
			showAdminControls();
			
			// Show notification
			showConnectionStatus("🎉 " + payload.message, 'success');
			
			// Update user's role badge in the UI
			updateUserRoleBadge('admin');
			
			setTimeout(() => {
				showConnectionStatus('', 'success'); // Clear the message
			}, 5000);
			
			console.log("=== YouAreNowOwner event completed ===");
		});
		// Handle room closure
		connection.on("RoomClosed", function (payload) {
			console.log("Room closed:", payload);
			showConnectionStatus(payload.message, 'warning');
			
			// Redirect to home page after a delay
			setTimeout(() => {
				window.location.href = '/';
			}, 5000);
		});

		connection.on("JoinSuccess", function(code, role) {
			console.log("Successfully joined room", code, "as", role);
		});

		connection.on("ReceiveUserList", function(users)
		{
			console.log("ReceiveUserList event received with", users.length, "users");
			
			// Clear existing user lists first to avoid duplicates
			const playerList = document.getElementById('playerList');
			const spectatorList = document.getElementById('spectatorList');
			
			if (playerList) playerList.innerHTML = '';
			if (spectatorList) spectatorList.innerHTML = '';
			
			// Deduplicate users by username before adding (client-side safety check)
			const uniqueUsers = [];
			const seenUsernames = new Set();
			
			users.forEach(user => {
				if (!seenUsernames.has(user.username)) {
					seenUsernames.add(user.username);
					uniqueUsers.push(user);
					console.log("Adding unique user: ", user.username, " (", user.points, " points)");
				} else {
					console.warn("Duplicate user detected in ReceiveUserList:", user.username, "- skipping");
				}
			});
			
			// Add all unique users
			uniqueUsers.forEach(user=>{
				addUserToDom(user);
			});
			
			// If we're a spectator, populate the player cards with existing users
			if (role === 'spectator') {
				console.log("Spectator role detected, populating player cards with existing users");
				populatePlayerCards(uniqueUsers);
			}
		});

		connection.on("GetRoomState", function(payload)
		{	
			console.log("GetRoomState event received:", payload);
			roundStarted(payload);
		});
		function roundStarted(payload)
		{
			const roundArea = document.getElementById('roundArea');
			const waitingArea = document.getElementById('waitingArea');
			
			// Convert DateTime to JavaScript timestamp
			let roundStartedAt;
			if (payload.roundStartedAt) {
				// If it's already a Unix timestamp (from RoundStarted)
				if (typeof payload.roundStartedAt === 'number') {
					roundStartedAt = payload.roundStartedAt;
				} else {
					// If it's a DateTime string (from GetRoomState)
					roundStartedAt = new Date(payload.roundStartedAt).getTime();
				}
			} else {
				// Fallback to current time
				roundStartedAt = Date.now();
			}

			if (roundArea) {
				roundArea.style.display = 'flex';
				roundArea.scrollIntoView({ behavior: 'smooth' });
			}
			if (waitingArea) { waitingArea.style.display = 'none'; }

			// Re-initialize role-based UI when game starts
			initializeRoleBasedUI();
			console.log("Round started at:", roundStartedAt);
			
			// Restart the game timer for each new round
			stopGameTimer(); // Stop any existing timer
			startGameTimer(roundStartedAt); // Start fresh timer for this round

			// Display consonants with better styling
			const consonantsEl = document.getElementById('consonantsDisplay');
			if (consonantsEl && payload.consonants) {
				const consonantsHtml = payload.consonants.map(c => `
					<span class="consonant-badge">${c.toUpperCase()}</span>
				`).join('');
				consonantsEl.innerHTML = consonantsHtml;
			}

			// Update game progress and progress bar
			if (payload.roundNumber) {
				const progressEl = document.getElementById('gameProgress');
				const progressBar = document.getElementById('progressBar');

				if (progressEl) {
					progressEl.innerText = `Round ${payload.roundNumber} of 10`;
				}

				if (progressBar) {
					const progressPercent = (payload.roundNumber / 10) * 100;
					progressBar.style.width = `${progressPercent}%`;
					progressBar.setAttribute('aria-valuenow', payload.roundNumber);
				}
			}

			// Update instructions
			const instructionsEl = document.getElementById('gameInstructions');
			if (instructionsEl && payload.message) {
				instructionsEl.innerText = payload.message;
			}

			const currentInput = getCurrentUserInput();
			if (currentInput) {
				currentInput.value = '';
				currentInput.focus();
			}
		}

		// Round start: show consonants and focus input
		connection.on("RoundStarted", function(payload){
			roundStarted(payload);
		});

		// Handle guess results
		connection.on("GuessResult", function(payload) {
			const maxNotifications = 5;
			const notificationDuration = 3000;

			let containerEl = document.getElementById('notificationContainer');
			if (!containerEl) {
				containerEl = document.createElement('div');
				containerEl.id = 'notificationContainer';
				document.body.appendChild(containerEl);
			}

			const alertClass = payload.success ? 'alert-success' : 'alert-danger';
			const notificationEl = document.createElement('div');
			notificationEl.className = `notification-item ${alertClass}`;
			notificationEl.innerHTML = payload.message;

			containerEl.prepend(notificationEl); 

			const notifications = containerEl.getElementsByClassName('notification-item');
			if (notifications.length > maxNotifications) {
				containerEl.removeChild(notifications[notifications.length - 1]);
			}

			setTimeout(() => {
				if (containerEl.contains(notificationEl)) {
					notificationEl.remove();
				}
			}, notificationDuration);
		});

		connection.on("ReceiveTypingInput", function(username, input) {
			if(role === 'spectator'){
				// Find the player card that belongs to this username
				const cardIndex = findCardIndexByUsername(username);
				console.log("Found card index for", username, ":", cardIndex);
				
				if(cardIndex > 0) {
					const inputElement = document.getElementById(`input${cardIndex}`);
					console.log("Input element found:", !!inputElement);
					
					if(inputElement) {
						inputElement.value = input;
						console.log("Updated input value to:", input);
						
						// Add typing indicator styling
						const card = document.getElementById(`playerCard${cardIndex}`);
						if(card) {
							card.classList.add('typing');
							
							// Remove typing indicator after a delay
							setTimeout(() => {
								card.classList.remove('typing');
							}, 2000);
						}
					} else {
						console.log("Input element not found for card", cardIndex);
					}
				} else {
					console.log("Could not find card index for username:", username);
				}
			}
		});

		// Helper function to find card index by username
		function findCardIndexByUsername(username) {
			console.log("Looking for username:", username);
			
			if (!username || username.trim() === '') {
				console.log("Invalid username provided");
				return -1;
			}
			
			for (let i = 1; i <= 4; i++) {
				const usernameElement = document.getElementById(`username${i}`);
				if (usernameElement) {
					const displayName = usernameElement.textContent.trim();
					const dataUsername = usernameElement.getAttribute('data-username');
					
					console.log(`Card ${i} - displayName: "${displayName}", dataUsername: "${dataUsername}"`);
					
					// Check both textContent and data attribute
					if (displayName === username || 
						displayName === `${username} (you)` ||
						dataUsername === username ||
						(displayName && displayName.includes(username))) {
						console.log(`Found match at card ${i}`);
						return i;
					}
				}
			}
			console.log("No card found for username:", username);
			return -1;
		}

		// Function to clear typing indicator for a user
		function clearTypingIndicator(username) {
			const cardIndex = findCardIndexByUsername(username);
			if(cardIndex > 0) {
				const card = document.getElementById(`playerCard${cardIndex}`);
				if(card) {
					card.classList.remove('typing');
				}
			}
		}

		// Handle game completion
		connection.on("GameCompleted", function(payload){
			// Stop the game timer when game completes
			stopGameTimer();
			
			if (payload.gameCompleted) {
				// Show completion modal
				const modal = document.getElementById('gameCompletionModal');
				if (modal) {
					const modalBody = document.getElementById('modalBody');
					if (modalBody) {
						// Get final scores from user lists
						const playerList = document.getElementById('playerList');
						const players = Array.from(playerList.querySelectorAll('.user-item')).map(item => {
							const username = item.querySelector('span').textContent;
							const pointsText = item.querySelector('.points-pill')?.textContent || '0 pts';
							const points = parseInt(pointsText.replace(' pts', '')) || 0;
							return { username, points };
						}).sort((a, b) => b.points - a.points);
						
						const leaderboardHtml = players.length > 0 ? `
							<div class="stat-card">
								<h5>🏆 Final Scores</h5>
								<div style="text-align: left;">
									${players.map((player, index) => `
										<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
											<span><strong>#${index + 1}</strong> ${player.username}</span>
											<span class="points-pill" style="font-size: 0.8rem;">${player.points} pts</span>
										</div>
									`).join('')}
								</div>
							</div>
						` : '';
						
						modalBody.innerHTML = `
							<div style="text-align: center;">
								<h3 style="color: var(--success); margin-bottom: 1rem;">🎉 Congratulations! 🎉</h3>
								<p style="font-size: 1.125rem; margin-bottom: 1.5rem;">${payload.message}</p>
								<div class="stats-grid">
									<div class="stat-card">
										<h5>📊 Game Statistics</h5>
										<p>
											<strong>Total Rounds:</strong> ${payload.totalRounds}<br>
											<strong>Game Type:</strong> Consonant Challenge<br>
											<strong>Language:</strong> Turkish
										</p>
									</div>
									${leaderboardHtml}
								</div>
							</div>
						`;
					}
					const bootstrapModal = new bootstrap.Modal(modal);
					bootstrapModal.show();
				}
			} else {
				// Legacy completion (for other scenarios)
				const roundArea = document.getElementById('roundArea');
				if (roundArea) {
					roundArea.innerHTML = `
						<div style="background: white; border-radius: 12px; padding: 2rem; text-align: center; box-shadow: var(--shadow-lg);">
							<h4 style="color: var(--info); margin-bottom: 1rem;">🎉 Game Completed! 🎉</h4>
							<p style="margin-bottom: 1.5rem;">${payload.message}</p>
						</div>
					`;
				}
			}
		});


		//events
		//on enter or spacebar hit, submit the guess with value, room code and username
		document.addEventListener('keydown', function(event) {
				if(event.key === 'Spacebar' || event.key === 'Enter')
				{
					// Only allow submission for players, not spectators
					if (role !== 'spectator') {
						const currentInput = getCurrentUserInput();
						if (currentInput) {
							//TODO: Publish the empty phase of the input. 
							shareTypingInput("");
							submitGuess(currentInput.value);
						}
					}
				}
		});
		function addUserToDom(user)
		{
			let username = user.username;
			let role = user.role;
			const listId = role === "player" ? "playerList" : "spectatorList";
			const listElement = document.getElementById(listId);
			
			// Check if user already exists in the list (prevent duplicates)
			const existingItems = listElement.querySelectorAll(`[data-username="${username}"]`);
			if (existingItems.length > 0) {
				console.warn("User", username, "already exists in", listId, "- skipping duplicate");
				return; // User already exists, don't add again
			}
			
			const listItem = document.createElement("div");
			listItem.className = "user-item";
			listItem.setAttribute('data-username', username);
			
			let itemContent = `
				<div class="user-info">
					<i class="bi bi-person-circle text-${role === 'player' ? 'success' : 'secondary'}"></i>
					<span>${username}</span>
				</div>
				<div class="user-actions">
					${role === 'player' ? `<span class="points-pill">${user.points || 0} pts</span>` : ''}
					<span class="badge badge-${role === 'player' ? 'success' : 'secondary'}">${role}</span>
			`;
			
			if(isAdmin && !user.isAdmin)
			{
				itemContent += `
					<button class="btn btn-sm btn-outline-danger" onclick="kickUser('${username}')">
						<i class="bi bi-x-lg"></i>
					</button>
				`;
			}
			
			itemContent += `</div>`;
			listItem.innerHTML = itemContent;
			listElement.appendChild(listItem);
		};

		function showAdminControls()
		{
			console.log("showAdminControls called for user:", currentUsername);
			
			// Check if admin controls already exist
			let adminControls = document.querySelector('.admin-controls');
			
			if (!adminControls) {
				console.log("Creating new admin controls...");
				// Create and inject admin controls
				adminControls = createAdminControlsElement();
				
				// Try multiple selectors to find the right container
				let userListsContainer = document.querySelector('.col-md-4');
				if (!userListsContainer) {
					userListsContainer = document.querySelector('.col-lg-4');
				}
				if (!userListsContainer) {
					userListsContainer = document.querySelector('.user-lists-container');
				}
				if (!userListsContainer) {
					// Fallback: find the container with user lists
					const playerList = document.getElementById('playerList');
					if (playerList) {
						userListsContainer = playerList.closest('.col-md-4') || playerList.closest('.col-lg-4') || playerList.parentElement.parentElement;
					}
				}
				
				if (userListsContainer) {
					console.log("Found container, appending admin controls");
					userListsContainer.appendChild(adminControls);
				} else {
					console.error("Could not find container for admin controls");
					// Fallback: append to body
					document.body.appendChild(adminControls);
				}
			} else {
				console.log("Showing existing admin controls");
				// Show existing admin controls
				adminControls.style.display = 'block';
			}

			// Add admin indicator to user list
			const userItems = document.querySelectorAll('.user-item');
			userItems.forEach(item => {
				const username = item.querySelector('span').textContent;
				if (username === currentUsername) {
					console.log("Adding admin styling to user:", username);
					// Add admin styling
					item.classList.add('admin-owner');
					
					// Add crown icon to indicate admin
					const userInfo = item.querySelector('.user-info');
					if (userInfo && !userInfo.querySelector('.admin-crown')) {
						const crown = document.createElement('i');
						crown.className = 'bi bi-crown-fill admin-crown text-warning ms-2';
						crown.title = 'Room Owner';
						userInfo.appendChild(crown);
					}
				}
			});

			console.log("Admin controls enabled for user:", currentUsername);
		}

		function createAdminControlsElement()
		{
			const adminControls = document.createElement('div');
			adminControls.className = 'admin-controls';
			adminControls.innerHTML = `
				<h5>
					<i class="bi bi-gear"></i>
					Controls
				</h5>
				<div class="admin-buttons">
					<button class="btn btn-success" onclick="startTheGame(true)">
						<i class="bi bi-play-fill"></i>
						Start Game
					</button>
					<button class="btn btn-outline-danger" onclick="closeTheGame()">
						<i class="bi bi-stop-fill"></i>
						Close Game
					</button>
				</div>
			`;
			return adminControls;
		}

		function updateUserRoleBadge(newRole)
		{
			// Update the user's role badge in both player and spectator lists
			const userItems = document.querySelectorAll('.user-item');
			userItems.forEach(item => {
				const username = item.querySelector('span').textContent;
				if (username === currentUsername) {
					const badge = item.querySelector('.badge');
					if (badge) {
						badge.textContent = newRole;
						badge.className = `badge badge-${newRole === 'admin' ? 'warning' : 'success'}`;
					}
				}
			});
		}

		function startTheGame(isAdmin)
		{
			// Only owner can start on server; client just requests
			connection.invoke('StartTheGame', parseInt(code), 1)
				.catch(err => console.error(err));
		}
		
		function closeTheGame()
		{
			if (confirm('Are you sure you want to close the game? This will end the session for all players.')) {
				// Close the room - you might want to implement this in the hub
				connection.invoke('CloseRoom', parseInt(code))
					.then(function () {
						// Redirect to home page
						setTimeout(() => {
							window.location.href = '/';
						}, 2000);
					})
					.catch(function (err) {
						console.error('Error closing room:', err.toString());
					});
			}
		}

		function kickUser(username)
		{
			if (confirm(`Are you sure you want to kick ${username} from the room?`)) {
				connection.invoke('KickUser', parseInt(code), username)
					.then(function () {
						console.log('User kick requested for:', username);
					})
					.catch(function (err) {
						console.error('Error kicking user:', err.toString());
						showConnectionStatus('Error kicking user', 'danger');
					});
			}
		}

		function startGameTimer(time)
		{
			console.log("Starting game timer with time:", time, "Current time:", Date.now());
			gameStartTime = time;
			
			gameTimerInterval = setInterval(function() {
				if (gameStartTime) {
					const elapsed = Date.now() - gameStartTime;
					const minutes = Math.floor(elapsed / 60000);
					const seconds = Math.floor((elapsed % 60000) / 1000);
					
					const timerElement = document.getElementById('gameTimer');
					if (timerElement) {
						timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
					}
				}
			}, 1000);
		}

		function stopGameTimer()
		{
			if (gameTimerInterval) {
				clearInterval(gameTimerInterval);
				gameTimerInterval = null;
			}
			gameStartTime = null;
			
			const timerElement = document.getElementById('gameTimer');
			if (timerElement) {
				timerElement.textContent = '00:00';
			}
		}

		function resetGameTimer()
		{
			stopGameTimer();
			startGameTimer(Date.now());
		}

		function submitGuess(guess)
		{
			connection.invoke('SubmitGuess', {guess: guess, code: code, username: username});
			const currentInput = getCurrentUserInput();
			if (currentInput) {
				currentInput.value = '';
				currentInput.focus();
			}
		}

		// Placeholder functions for future typing indicators feature
		function showTypingIndicator(username) {
			// This will be implemented when you add the hub function
			console.log(`${username} started typing`);
		}

		function hideTypingIndicator(username) {
			// This will be implemented when you add the hub function
			console.log(`${username} stopped typing`);
		}

		function updateTypingPlayersList(typingUsers) {
			// This will be implemented when you add the hub function
			const typingArea = document.getElementById('typingIndicatorsArea');
			const typingList = document.getElementById('typingPlayersList');
			
			if (typingUsers && typingUsers.length > 0) {
				if (typingArea) typingArea.style.display = 'block';
				if (typingList) {
					typingList.innerHTML = typingUsers.map(user => 
						`<div class="typing-player">
							<i class="bi bi-three-dots"></i>
							${user}
						</div>`
					).join('');
				}
			} else {
				if (typingArea) typingArea.style.display = 'none';
			}
		}

		// Debug function to manually test card population
		window.debugCards = function() {
			console.log("=== DEBUG CARDS ===");
			console.log("Current role:", role);
			console.log("Current username:", currentUsername);
			
			for (let i = 1; i <= 4; i++) {
				const card = document.getElementById(`playerCard${i}`);
				const usernameEl = document.getElementById(`username${i}`);
				const roleEl = document.getElementById(`role${i}`);
				const input = document.getElementById(`input${i}`);
				
				console.log(`Card ${i}:`);
				console.log("  - Card element:", !!card);
				console.log("  - Username element:", !!usernameEl);
				console.log("  - Username text:", usernameEl ? usernameEl.textContent : "N/A");
				console.log("  - Data username:", usernameEl ? usernameEl.getAttribute('data-username') : "N/A");
				console.log("  - Role element:", !!roleEl);
				console.log("  - Role text:", roleEl ? roleEl.textContent : "N/A");
				console.log("  - Input element:", !!input);
				console.log("  - Card display:", card ? card.style.display : "N/A");
			}
			
			console.log("=== END DEBUG ===");
		};

		// Debug function to manually test card population with test data
		window.testPopulateCards = function() {
			console.log("=== TEST POPULATE CARDS ===");
			const testUsers = [
				{username: "KnowledgeBeast", role: "player"},
				{username: "ShortCircuit", role: "spectator"}
			];
			console.log("Testing with users:", testUsers);
			populatePlayerCards(testUsers);
		};

		// Force populate cards with actual current users
		window.forcePopulateCards = function() {
			console.log("=== FORCE POPULATE CARDS ===");
			console.log("Forcing spectator grid to show");
			document.getElementById('spectatorGridArea').style.display = 'grid';
			document.getElementById('playerInputArea').style.display = 'none';
			
			// Get users from the sidebar lists
			const playerList = document.getElementById('playerList');
			const spectatorList = document.getElementById('spectatorList');
			
			const users = [];
			
			// Get players
			if (playerList) {
				const playerItems = playerList.querySelectorAll('.user-item');
				playerItems.forEach(item => {
					const usernameSpan = item.querySelector('.user-info span');
					if (usernameSpan) {
						users.push({
							username: usernameSpan.textContent.trim(),
							role: 'player'
						});
					}
				});
			}
			
			// Get spectators
			if (spectatorList) {
				const spectatorItems = spectatorList.querySelectorAll('.user-item');
				spectatorItems.forEach(item => {
					const usernameSpan = item.querySelector('.user-info span');
					if (usernameSpan) {
						users.push({
							username: usernameSpan.textContent.trim(),
							role: 'spectator'
						});
					}
				});
			}
			
			console.log("Found users from sidebar:", users);
			populatePlayerCards(users);
		};
	</script>
}

<div class="bg-gradient">
	<div class="container" style="max-width: 1400px; margin: 0 auto;">
		<!-- Compact Header -->
		<div class="game-header">
			<h2>
				<i class="bi bi-controller"></i>
				Trivio Game
			</h2>
			<div class="game-code">
				<span>@Model.Code</span>
					<i class="bi bi-copy"></i>
				</div>
			</div>

		<!-- Main Game Layout -->
		<div class="game-layout">
			<!-- Sidebar: Players & Controls -->
			<div class="sidebar-card">
				<div class="sidebar-header">
					<i class="bi bi-people-fill"></i>
					Room Info
				</div>
				<div class="sidebar-body">
					<!-- Players Section -->
					<div class="user-section">
						<div class="user-section-title">
							<i class="bi bi-person-check"></i>
							Players
						</div>
						<div id="playerList" class="user-list">
							<!-- Players will be added here -->
						</div>
					</div>
					
					<!-- Spectators Section -->
					<div class="user-section">
						<div class="user-section-title">
							<i class="bi bi-eye"></i>
							Spectators
						</div>
						<div id="spectatorList" class="user-list">
							<!-- Spectators will be added here -->
						</div>
				</div>
				
					<!-- Admin Controls -->
				@if (Model.IsAdmin)
				{
						<div class="admin-controls">
							<h5>
								<i class="bi bi-gear"></i>
								Controls
							</h5>
							<button class="btn btn-success" onclick="startTheGame(true)">
								<i class="bi bi-play-fill"></i>
								Start Game
							</button>
							<button class="btn btn-outline-danger" onclick="closeTheGame()">
								<i class="bi bi-stop-fill"></i>
								Close Game
							</button>
						</div>
					}
				</div>
			</div>

			<!-- Game Area -->
			<div>
				<!-- Active Game Area -->
				<div id="roundArea" style="display:none;" class="game-card">
					<div class="game-header-bar">
						<h4>
							<i class="bi bi-trophy"></i>
							Consonant Challenge
						</h4>
						<div class="game-timer">
							<i class="bi bi-clock"></i>
							<span id="gameTimer">00:00</span>
						</div>
					</div>
					<div class="game-content">
						<!-- Progress Section -->
						<div class="progress-section">
							<div id="gameProgress" class="round-number">
								Round 1 of 10
							</div>
							<div class="progress-bar-container">
								<div id="progressBar" class="progress-bar" role="progressbar" style="width: 10%" aria-valuenow="1" aria-valuemin="0" aria-valuemax="10"></div>
							</div>
						</div>
						
						<!-- Instructions -->
						<div class="instructions">
							<h5 id="gameInstructions">
								Use only these consonants:
							</h5>
						</div>
						
						<!-- Consonants Display -->
						<div class="consonants-container">
							<div id="consonantsDisplay">
								<!-- Consonants will be displayed here -->
							</div>
						</div>
						
						<!-- Player Input Area (for players only) -->
						<div id="playerInputArea" class="input-area">
							<input type="text" 
								   id="guessInput" 
								   class="guess-input"
								   placeholder="Type a word using only the consonants above..." 
								   autocomplete="off">
						</div>

						<!-- Four Player Grid Layout (for spectators only) -->
						<div id="spectatorGridArea" class="players-grid" style="display: none;">
							<!-- Player 1 Card -->
							<div class="player-card" id="playerCard1">
								<div class="player-header">
									<span class="player-username" id="username1"></span>
									<span class="player-role" id="role1"></span>
								</div>
								<div class="player-input-container">
									<input type="text" 
										   class="player-input" 
										   id="input1"
										   placeholder="Type a word..." 
										   autocomplete="off"
										   disabled>
								</div>
								<div class="player-status" id="status1"></div>
							</div>

							<!-- Player 2 Card -->
							<div class="player-card" id="playerCard2">
								<div class="player-header">
									<span class="player-username" id="username2"></span>
									<span class="player-role" id="role2"></span>
								</div>
								<div class="player-input-container">
									<input type="text" 
										   class="player-input" 
										   id="input2"
										   placeholder="Type a word..." 
										   autocomplete="off"
										   disabled>
								</div>
								<div class="player-status" id="status2"></div>
							</div>

							<!-- Player 3 Card -->
							<div class="player-card" id="playerCard3">
								<div class="player-header">
									<span class="player-username" id="username3"></span>
									<span class="player-role" id="role3"></span>
								</div>
								<div class="player-input-container">
									<input type="text" 
										   class="player-input" 
										   id="input3"
										   placeholder="Type a word..." 
										   autocomplete="off"
										   disabled>
								</div>
								<div class="player-status" id="status3"></div>
							</div>

							<!-- Player 4 Card -->
							<div class="player-card" id="playerCard4">
								<div class="player-header">
									<span class="player-username" id="username4"></span>
									<span class="player-role" id="role4"></span>
								</div>
								<div class="player-input-container">
									<input type="text" 
										   class="player-input" 
										   id="input4"
										   placeholder="Type a word..." 
										   autocomplete="off"
										   disabled>
								</div>
								<div class="player-status" id="status4"></div>
							</div>
						</div>
						
						<!-- Message Area -->
						<div id="messageArea">
							<!-- Messages will be displayed here -->
						</div>
					</div>
			</div>

				<!-- Waiting Area -->
				<div id="waitingArea" class="waiting-card">
					<div class="waiting-icon">
						<i class="bi bi-hourglass-split"></i>
					</div>
					<h3>Waiting for game to start...</h3>
					<p>The room admin will start the game when ready.</p>
				</div>
		</div>
		</div>
	</div>
</div>

<!-- Game Completion Modal -->
<div class="modal fade" id="gameCompletionModal" tabindex="-1" aria-labelledby="gameCompletionModalLabel" aria-hidden="true">
	<div class="modal-dialog modal-lg">
		<div class="modal-content">
			<div class="modal-header" style="background: var(--success); color: white;">
				<h5 class="modal-title" id="gameCompletionModalLabel">Game Completed!</h5>
				<button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
			</div>
			<div class="modal-body" id="modalBody">
				<!-- Modal content will be populated by JavaScript -->
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-outline-danger" data-bs-dismiss="modal">Close</button>
				<button type="button" class="btn btn-success" onclick="location.reload()">Play Again</button>
			</div>
		</div>
	</div>
</div>